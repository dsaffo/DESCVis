<html>
<head>
<meta charset="utf-8">
<style>
body {
    margin: 0;
    user-select: none;
}
.nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
}
</style>
</head>
<body collaboration="safe" ignore-events="all" custom-events="dot-created,dot-moved,dot-moved-finished">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://unpkg.com/d3-marcon/build/d3-marcon.min.js"></script>
<script src="https://unpkg.com/peerjs@1.0.4/dist/peerjs.min.js"></script>
<script src="../../visconnect-bundle.js"></script>
<script>

const questions = [{
    q: 'In what areas would collaborative visualization be useful?',
    a: [{a: 'Art', icon: 'art.png'}, {a: 'Health Care', icon: 'health-care.png'},
        {a: 'Science', icon: 'science.png'}, {a: 'Education', icon: 'education.png'}]
}, {
    q: 'Have you been interested in making any of your visualizations collaborative?',
    a: [{a: 'Yes, and we did it.'}, {a: 'Yes, but we did not end up making it collaborative.'},
        {a: 'No, I haven\'t thought about collaboration in my visualizations.'},
        {a: 'No, I don\'t think collaboration would be helpful in my visualizations.'}]
}, {
    q: 'What are challenges to making visualizations collaborative?',
    a: [{a: 'Implementation'}, {a: 'Strategies to divide the work'}, {a: 'Interaction'},
        {a: 'Conflict Resolution'}]
}];

const votingBeeswarm = function(question) {

    var m = d3.marcon().width(window.innerWidth).height(window.innerHeight);
    m.render();
    var width = m.innerWidth(),
        height = m.innerHeight(),
        svg = m.svg();

    const numberItems = 100;
    var nodes = []; /*d3.range(numberItems).map(function(i) {
        return { index: i, x: Math.random() * width, y: Math.random() * height };
    });*/

    const linesG = svg.append('g')
        .attr('class', 'lines');

    const answers = svg.append('g')
        .attr('class', 'answers');

    const numberAnswers = question.a.length;
    const gridWidth = Math.round(width / (numberAnswers + 1));
    let centerPoints = [];
    for(let i = 0; i < numberAnswers; i++) {
        const x = (i + 1) * gridWidth;
        centerPoints.push({x, y: height / 2 + 100});
        const answer = question.a[i];

        /*const rectWidth = gridWidth - 80;
        answers.append('rect')
            .attr('x', x - rectWidth / 2)
            .attr('y', 150)
            .attr('width', rectWidth)
            .attr('height', height - 300)
            .attr('rx', 30)
            .attr('ry', 30)
            .attr('fill-opacity', '0.3')
            .attr('fill', '#ddc4aa')
            .style('cursor', 'pointer')
            .on('mouseenter', function() {
                d3.select(this).attr('fill', '#e7aa6d')
            }).on('mouseleave', function() {
                d3.select(this).attr('fill', '#ddc4aa')
            });*/

        answers.append('text')
            .html(answer.a)
            .attr('x', x)
            .attr('y', 220)
            .attr('text-anchor', 'middle')
            .attr('font-size', '30');

        if(answer.icon) {
            answers.append('image')
                .attr('href', 'img/' + answer.icon)
                .attr('x', x - 75)
                .attr('y', 240)
                .attr('width', 150)
        }

        nodes.push({x, y: height - 250, id: vc.random().toString(36).substr(2, 9)});
    }

    const gravityForce = (function(centerPoints) {
        const force = (alpha) => {
            if(force.savedNodes && force.savedNodes.length) {
                for(const node of force.savedNodes) {
                    force.applyGravityToNode(alpha, node);
                }
            }
        };

        force.applyGravityToNode = (alpha, node) => {
            node.lastPos = {x: node.x, y: node.y};

            const dragCoefficient = -0.3;
            const drag = !node.gravitySpeed ? {x:0, y:0} : {
                x: node.gravitySpeed.x * dragCoefficient,
                y: node.gravitySpeed.y * dragCoefficient
            };
            node.x += drag.x;
            node.y += drag.y;
            node.gravitySpeed = {x: drag.x, y: drag.y};

            for(const centerPoint of centerPoints) {
                const difference = {
                    x: centerPoint.x - node.x,
                    y: centerPoint.y - node.y
                };
                const differenceLength = Math.sqrt(Math.pow(difference.x, 2) + Math.pow(difference.y, 2));

                const boundaryRadius = Math.sqrt(numberItems) * 15;
                let speed = {x: 0, y: 0};

                if(differenceLength < boundaryRadius) {
                    speed = {
                        x: difference.x * alpha * force.currentStrength / Math.pow(boundaryRadius, 3),
                        y: difference.y * alpha * force.currentStrength / Math.pow(boundaryRadius, 3),
                    };
                } else {
                    speed = {
                        x: difference.x / Math.pow(differenceLength, 3) * alpha * force.currentStrength,
                        y: difference.y / Math.pow(differenceLength, 3) * alpha * force.currentStrength
                    };
                }

                node.x += speed.x;
                node.y += speed.y;

                node.gravitySpeed.x += speed.x;
                node.gravitySpeed.y += speed.y;
            }
        }

        force.savedNodes = [];
        force.currentStrength = 1;

        force.initialize = (nodes) => {
            if(!nodes || !nodes.length) {
                return;
            }
            force.savedNodes = nodes;
        };

        force.strength = (strength) => {
            force.currentStrength = strength;
            return force;
        };

        return force;
    });
    const gravity = gravityForce(centerPoints).strength(200000);

    const lineGen = d3.line();

    const lineStarts = [];

    // Top
    for(let i = 0; i < 100; i++) {
        lineStarts.push({x: 50 + i * (width-100) / 100, y: 50});
    }
    // Bottom
    for(let i = 0; i < 100; i++) {
        lineStarts.push({x: 50 + i * (width-100) / 100, y: height - 50});
    }
    // Left
    for(let i = 0; i < 50; i++) {
        lineStarts.push({x: 50, y: 50 + i * (height-100) / 50});
    }
    // Right
    for(let i = 0; i < 50; i++) {
        lineStarts.push({x: width - 50, y: 50 + i * (height-100) / 50});
    }

    for(const lineStart of lineStarts) {
        const positions = [[lineStart.x, lineStart.y]];
        for(let step = 0; step < 500; step++) {
            gravity.applyGravityToNode(1, lineStart);
            positions.push([lineStart.x, lineStart.y]);
        }
        linesG.append('path')
            .attr('d', lineGen(positions))
            .attr('stroke', '#e5e5e5')
            .attr('fill', 'none');
    }

    var simulation = d3.forceSimulation().alphaDecay(0.000002)
        .force("gravity", gravity)
        .force('collision', d3.forceCollide().radius(10))
        .on("tick", ticked);

    var nodesG = svg.append("g")
        .attr("class", "nodes");

    const drag = d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended);

    const updateVis = () => {
        const nodesSelection = nodesG
            .selectAll("circle")
            .data(nodes, d => d.id);

        nodesSelection.exit().remove();

        nodesSelection
            .enter().append("circle")
            .attr("r", function(d) { return 8 })
            .attr('id', function(d) { return 'node-' + d.id; })
            .attr("fill", function(d) { return d.color ? d.color : '#777'; })
            .call(drag);

        simulation
            .nodes(nodes)
            .restart();
    }
    updateVis();

    function ticked() {
        nodesG
            .selectAll("circle")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
    }

    let lastDragTime = 0;
    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        lastDragTime = 0;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
        if(Date.now() - lastDragTime > 100) {
            lastDragTime = Date.now();
            const event = new CustomEvent('dot-moved', {detail: { x: d3.event.x / width, y: d3.event.y / height, id: d.id }});
            document.body.dispatchEvent(event);
        }
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
        const event = new CustomEvent('dot-moved-finished', {detail: { x: d3.event.x / width, y: d3.event.y / height, id: d.id }});
        document.body.dispatchEvent(event);
        lastDragTime = Date.now();
    }

    d3.select('body').on('click', () => {
        if(d3.event.target === svg.node().parentNode && Date.now() - lastDragTime > 150) {
            const event = new CustomEvent('dot-created', {detail: { x: d3.event.x / width, y: d3.event.y / height, id: Math.random().toString(36).substr(2, 9) }});
            document.body.dispatchEvent(event);
        }
    });

    document.body.addEventListener('dot-created', (e) => {
        nodes.push({x: e.detail.x * width, y: e.detail.y * height, color: e.collaboratorColor, id: e.detail.id});
        updateVis();
    });

    document.body.addEventListener('dot-moved', (e) => {
        if(!e.isLocalEvent) {
            const filtered = nodes.filter(n => n.id === e.detail.id);
            if(filtered.length === 1) {
                const node = filtered[0];
                node.fx = e.detail.x * width;
                node.fy = e.detail.y * height;
                updateVis();
            }
        }
    });
    document.body.addEventListener('dot-moved-finished', (e) => {
        if(!e.isLocalEvent) {
            const filtered = nodes.filter(n => n.id === e.detail.id);
            if(filtered.length === 1) {
                const node = filtered[0];
                node.x = e.detail.x * width;
                node.y = e.detail.y * height;
                node.fx = null;
                node.fy = null;
                updateVis();
            }
        }
    });

    svg.append('text')
        .html(question.q)
        .attr('x', width / 2)
        .attr('y', 100)
        .attr('text-anchor', 'middle')
        .attr('font-size', '40');
};

votingBeeswarm(questions[0]);

</script>
</body>
</html>
